package popcountmap

// pc[i] is the population count of i.
var pc [256]byte

// 0 -> 00000000 –> 0
// 1 –> 00000001 –> 1
// 2 –> 00000010 –> 1
// 3 –> 00000011 –> 2
// ...
// 15 –> 00001111 –> 4
// ...
// 252 –> 11111100 –> 6
// 253 –> 11111101 –> 7
// 254 –> 11111110 –> 7
// 255 –> 11111111 –> 8
func init() {
  // pc[0] = pc[0 / 2] + (0 & 1) = pc[0] + 000000000 = 000000000 + 000000000 = 000000000 = 0
  // pc[1] = pc[1 / 2] + (1 & 1) = pc[0] + 000000001 = 000000000 + 000000001 = 000000001 = 1
  // pc[2] = pc[2 / 2] + (2 & 1) = pc[1] + 000000000 = 000000001 + 000000000 = 000000001 = 1
  // pc[3] = pc[3 / 2] + (3 & 1) = pc[1] + 000000001 = 000000001 + 000000001 = 000000010 = 2
  // ...
  // pc[15] = pc[15 / 2] + (15 & 1) = pc[7] + 000000001 = 000000011 + 000000001 = 000000100 = 4
  // ...
  // pc[252] = pc[252 / 2] + (252 & 1) = pc[126] + 000000000 = 000000110 + 000000000 = 000000110 = 6
  // pc[253] = pc[253 / 2] + (253 & 1) = pc[127] + 000000001 = 000000110 + 000000001 = 000000111 = 7
  // pc[254] = pc[254 / 2] + (254 & 1) = pc[128] + 000000000 = 000000111 + 000000000 = 000000111 = 7
  // pc[255] = pc[255 / 2] + (255 & 1) = pc[128] + 000000001 = 000000111 + 000000001 = 000001000 = 8
  for i := range pc {
    pc[i] = pc[i/2] + byte(i&1)
  }
}

// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
  // x = 0x0F0F0F0F0F0F0F0F
  //        0   F    0   F    0   F    0   F    0   F    0   F    0   F    0   F
  //     00001111 00001111 00001111 00001111 00001111 00001111 00001111 00001111
  // pc[15] + pc[15] + pc[15] + pc[15] + pc[15] + pc[15] + pc[15] + pc[15] = 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 = 32
  return int(pc[byte(x>>(0*8))] +
    pc[byte(x>>(1*8))] +
    pc[byte(x>>(2*8))] +
    pc[byte(x>>(3*8))] +
    pc[byte(x>>(4*8))] +
    pc[byte(x>>(5*8))] +
    pc[byte(x>>(6*8))] +
    pc[byte(x>>(7*8))])
}
